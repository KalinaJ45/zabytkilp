# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ZabytkiLPDialog
                                 A QGIS plugin
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-02-02
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Kalina Juszczyk
        email                : kalina.juszczyk@lasy.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.core import *
from qgis.utils import iface
from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
from PyQt5.QtCore import QVariant

from .function_kind import FunctionKindEnum
from .category_kind import CategoryKindEnum
from .document_kind import DokumentKindEnum
from .field_kind import FieldKindEnum


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ZabytkiLP_dialog_base.ui'))


class ZabytkiLPDialog(QtWidgets.QDialog, FORM_CLASS):
    """The main plugin class.
    """

    def __init__(self, parent=None):
        """Constructor."""
        super(ZabytkiLPDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer function by doing
        # self.<functionname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.save_layer_path = ""
        self.open_layer_path = ""

        self.createLayerRBtn.toggled.connect(self.set_state_of_widgets)
        self.editLayerRBtn.toggled.connect(self.set_state_of_widgets)
        self.pointRBtn.toggled.connect(
            lambda: self.set_enabled_of_widget({self.saveLayerBox: True}))
        self.lineRBtn.toggled.connect(
            lambda: self.set_enabled_of_widget({self.saveLayerBox: True}))
        self.polygonRBtn.toggled.connect(
            lambda: self.set_enabled_of_widget({self.saveLayerBox: True}))
        self.outputBtn.clicked.connect(self.create_layer_path)
        self.createLayerBtn.clicked.connect(self.create_layer)
        self.inputBtn.clicked.connect(self.get_layer_path)
        self.openLayerBtn.clicked.connect(self.open_layer)
        self.closeBtn.clicked.connect(self.close_window_plugin)
        self.clearBtn.clicked.connect(self.clear_form)

    def set_enabled_of_widget(self, enabled_of_widets):
        """Sets if widgets is enabled or not.

        Args:
            enabled_of_widets (dict): dictionary in which the keys are widgets (QtWidgets) and the values are True or False (bool) depending on whether the widget  should be enabled or not.
        """
        for widget in enabled_of_widets:
            widget.setEnabled(enabled_of_widets[widget])

    def clear_widget(self, widgets):
        """Clears selected widges.

        Args:
            widgets (list): list of widgets (QtWidgets).
        """
        for widget in widgets:
            widget.clear()

    def set_exclusive_of_butons_group(self, exclusivity_of_buttons_group):
        """Sets exclusivity of buttons group.

        Args:
            exclusivity_of_buttons_group (dict): dictionary in which the keys are buttons groups (QButtonGroup) and the values are True or False (bool) depending on whether the buttons group should be exclusive or not.
        """
        for buttons_group in exclusivity_of_buttons_group:
            buttons_group.setExclusive(
                exclusivity_of_buttons_group[buttons_group])

    def set_checked_of_widget(self, checked_of_widgets):
        """Sets if widgets is checked or not.

        Args:
            checked_of_widgets (dict): dictionary in which the keys are widgets (QtWidgets) and the values are True or False (bool) depending on whether the widget  should be checked or not.
        """
        for widget in checked_of_widgets:
            widget.setChecked(checked_of_widgets[widget])

    def set_state_of_widgets(self):
        """Sets state of widgets depending on the selection of options of creating or editing the layer with monuments.
        """
        if self.createLayerRBtn.isChecked() == True:
            self.set_enabled_of_widget(
                {self.createLayerBox: True, self.clearBtn: True, self.selectGeometryBox: True, self.editLayerBox: False})
            self.set_exclusive_of_butons_group({self.geometryBtnGroup: True})
            self.set_checked_of_widget(
                {self.pointRBtn: False, self.lineRBtn: False, self.polygonRBtn: False})
        if self.editLayerRBtn.isChecked() == True:
            self.set_enabled_of_widget(
                {self.createLayerBox: False, self.clearBtn: True, self.openLayerBtn: False, self.editLayerBox: True})
            self.set_exclusive_of_butons_group({self.geometryBtnGroup: False})
            self.set_checked_of_widget(
                {self.pointRBtn: False, self.lineRBtn: False, self.polygonRBtn: False})

    def create_layer_path(self):
        """Opens dialog box to selecte created layer saving paths. In the event of a problem an message appears.
        """
        self.save_layer_path = QFileDialog.getSaveFileName(
            None, "Wybierz lokalizację", self.create_layers_names()[0], '*.shp')
        if len(self.save_layer_path[0]) == 0:
            msg = QMessageBox.critical(
                None, "Wybierz lokalizację zapisu pliku", "Nie wybrano lokalizacji!")
        else:
            self.set_enabled_of_widget(
                {self.selectGeometryBox: False,  self.createLayerBtn: True})
            self.outputLE.setText(self.save_layer_path[0])

    def create_layers_names(self) -> str:
        """Creates names of created layer for monuments and temporary layer with funcions of monuments (depending on the selected type of geometry) and return it. 

        Returns:
            str : names of created layer for monuments and temporary layer with funcions of monuments.
        """
        if self.polygonRBtn.isChecked() == True or "zabytki_powierzchniowe" in self.inputLE.text():
            layer_name = "zabytki_powierzchniowe"
            function_layer_name = "Funkcje_zabytki_powierzchniowe"
        if self.pointRBtn.isChecked() == True or "zabytki_punktowe" in self.inputLE.text():
            layer_name = "zabytki_punktowe"
            function_layer_name = "Funkcje_zabytki_punktowe"
        if self.lineRBtn.isChecked() == True or "zabytki_liniowe" in self.inputLE.text():
            layer_name = "zabytki_liniowe"
            function_layer_name = "Funkcje_zabytki_liniowe"
        return layer_name, function_layer_name

    def select_geometry_type(self) -> QgsWkbTypes:
        """Selection of geometry type for layer (created or edited).

        Returns:
           QgsWkbTypes: selected type of geomery for layer (created or edited).
        """
        if self.polygonRBtn.isChecked() == True:
            geometry_type = QgsWkbTypes.MultiPolygon
        if self.pointRBtn.isChecked() == True:
            geometry_type = QgsWkbTypes.MultiPoint
        if self.lineRBtn.isChecked() == True:
            geometry_type = QgsWkbTypes.MultiLineString
        return geometry_type

    def set_field_alias(self, layer):
        """Sets aliases for fields of created vector layer for monuments (shapefile) from class FieldKindEnum.

        Args:
            layer (QgsVectorLayer): created vector layer with monuments.
        """
        for field in FieldKindEnum:
            layer.setFieldAlias(field.value.index, field.value.alias_field)

    def create_functions_and_categories_lists(self) -> list:
        """  Creates lists of monuments functions and categories from classes FunctionKindEnum and CategoryKindEnum depending on the selected type of geometry.

        Returns:
            list: lists of monuments functions and categories
        """
        if (self.polygonRBtn.isChecked() == True) or "zabytki_powierzchniowe" in self.inputLE.text():
            functions_list = [
                function.value.function for function in FunctionKindEnum if 'POLYGON' in function.value.geometry]
            categories_list = [
                category.value.category for category in CategoryKindEnum if 'POLYGON' in category.value.geometry]
        if (self.pointRBtn.isChecked() == True) or "zabytki_punktowe" in self.inputLE.text():
            functions_list = [
                function.value.function for function in FunctionKindEnum if 'POINT' in function.value.geometry]
            categories_list = [
                category.value.category for category in CategoryKindEnum if 'POINT' in category.value.geometry]
        if (self.lineRBtn.isChecked() == True) or "zabytki_liniowe" in self.inputLE.text():
            functions_list = [
                function.value.function for function in FunctionKindEnum if 'LINE' in function.value.geometry]
            categories_list = [
                category.value.category for category in CategoryKindEnum if 'LINE' in category.value.geometry]
        return functions_list, categories_list

    def hide_functions_layer(self, layer):
        """Hides layer in Qgis project legend.

        Args:
            layer (QgsVectorLayer): Temporary Vector layers.
        """
        model = iface.layerTreeView().layerTreeModel()
        ltv = iface.layerTreeView()
        root = QgsProject.instance().layerTreeRoot()
        node = root.findLayer(layer.id())
        index = model.node2index(node)
        ltv.setRowHidden(index.row(), index.parent(), True)
        node.setCustomProperty('nodeHidden', 'true')
        ltv.setCurrentIndex(model.node2index(root))

    def create_functions_layer(self):
        """Create temporary function layer depending on the selected type of geometry.
        """
        function_list = self.create_functions_and_categories_lists()[0]
        functons_layer = QgsVectorLayer(
            'None', self.create_layers_names()[1], 'memory')
        pr = functons_layer.dataProvider()
        functons_layer.startEditing()
        pr.addAttributes([QgsField('FUNKCJA', QVariant.String),
                         QgsField('KATEG', QVariant.String)])
        feature = QgsFeature()
        for function in FunctionKindEnum:
            for monument_function in function_list:
                if function.value.function == monument_function:
                    feature.setAttributes(
                        [function.value.function, function.value.category])
                    pr.addFeatures([feature])
        functons_layer.commitChanges()
        QgsProject.instance().addMapLayer(functons_layer)
        self.hide_functions_layer(functons_layer)

    def set_widget(self, parmeters, layer, index):
        """Sets the widget type and its configuration for a vector layer field.
        Args:
            parmeters (tuple): tuple consisting of type of widgets and dictionary of widget parameters and their values: (type: str, config: Dict[str, Any])
            layer (QgsVectorLayer): vector layer.
            index (int): index of specified field of vecor layer.
        """
        editor_widget_setup = QgsEditorWidgetSetup(*parmeters)
        layer.setEditorWidgetSetup(index, editor_widget_setup)

    def give_layer_style(self, layer):
        """Gives style of created layer for monuments and configurate its widgets.

        Args:
            layer (QgsVectorLayer): created vecor layer.
        """
        for field in FieldKindEnum:
            if field.value.widget_type == 'CheckBox':
                self.set_widget(('CheckBox', {
                                'CheckedState': 'TAK', 'UncheckedState': 'NIE'}), layer, field.value.index)
            if field.value.widget_type == 'ValueMap':
                if field.value.field_name == 'KATEG':
                    self.set_widget(
                        ('ValueMap', {'map': dict(zip(self.create_functions_and_categories_lists()[1], self.create_functions_and_categories_lists()[1]))}), layer, field.value.index)
                if field.value.field_name == 'RODZ_DOKUM':
                    self.set_widget(('ValueMap', {'map': {
                                    document.value.type: document.value.code for document in DokumentKindEnum}}), layer, field.value.index)
            if field.value.field_name == "FUNKCJA":
                self.set_widget(('ValueRelation', {'AllowMulti': False, 'AllowNull': True, 'FilterExpression': '"KATEG"=current_value(\'KATEG\')', 'Key': 'FUNKCJA',
                                'LayerName': self.create_layers_names()[1], 'LayerProviderName': 'memory', 'NofColumns': 1, 'OrderByValue': True, 'UseCompleter': False, 'Value': 'FUNKCJA'}), layer, field.value.index)
            if field.value.not_null == True:
                layer.setFieldConstraint(
                    field.value.index, QgsFieldConstraints.ConstraintNotNull)

    def clear_createLayerBox(self):
        """Clears the box to layer create.
        """
        self.save_layer_path == ""
        self.clear_widget([self.outputLE])
        self.set_enabled_of_widget(
            {self.selectGeometryBox: True, self.createLayerBtn: False})

    def clear_editLayerBox(self):
        """Clears the box to layer edit.
        """
        self.open_layer_path = ""
        self.clear_widget([self.inputLE])
        self.set_enabled_of_widget(
            {self.openLayerBtn: False})

    def create_layer(self):
        """Create layer for monuments about selected type of geometry and predefined name and save it in selected location. In the event of a problem an message appears.
        """
        layers_list = QgsProject.instance().mapLayersByName(
            self.create_layers_names()[0])
        if layers_list == []:
            fields = QgsFields()
            for field in FieldKindEnum:
                fields.append(QgsField(field.value.field_name,
                              QVariant.String, "text", field.value.long_field))
            crs = QgsCoordinateReferenceSystem('EPSG:2180')
            transform_context = QgsProject.instance().transformContext()
            save_options = QgsVectorFileWriter.SaveVectorOptions()
            save_options.driverName = "ESRI Shapefile"
            save_options.fileEncoding = "UTF-8"
            if Qgis.QGIS_VERSION_INT >= 31030:
                writer = QgsVectorFileWriter.create(
                    self.save_layer_path[0], fields, self.select_geometry_type(), crs, transform_context, save_options)
            else:
                writer = QgsVectorFileWriter(
                    self.save_layer_path[0], 'UTF-8', fields,  self.select_geometry_type(), crs, "ESRI Shapefile")
            if writer.hasError() != QgsVectorFileWriter.NoError:
                msg = QMessageBox.critical(
                    None, "Spróbuj jeszcze raz", "Problem z zapisem warstwy!")
                self.clear_createLayerBox()
            else:
                del writer
                layer = QgsVectorLayer(
                    self.save_layer_path[0], self.create_layers_names()[0], 'ogr')
                self.set_field_alias(layer)
                if layer.isValid():
                    QgsProject.instance().addMapLayers([layer])
                    self.create_functions_layer()
                    self.give_layer_style(layer)
                    try:
                        path_qml = self.save_layer_path[0][:-4]+'.qml'
                        layer.saveNamedStyle(path_qml)
                    except:
                        msg = QMessageBox.critical(
                            None, "Spróbuj jeszcze raz utowrzyć warstwę", "Problem z zapisem pliku .qml!")
                        QgsProject.instance().removeMapLayer(QgsProject.instance(
                        ).mapLayersByName(self.create_layers_names()[0])[0].id())
                        QgsProject.instance().removeMapLayer(QgsProject.instance(
                        ).mapLayersByName(self.create_layers_names()[1])[0].id())
                    finally:
                        self.clear_createLayerBox()
                else:
                    msg = QMessageBox.critical(
                        None, "Spróbuj jeszcze raz utowrzyć warstwę", "Problem z ładowaniem warstwy do projektu!")
                    self.clear_createLayerBox()
        else:
            msg = QMessageBox.critical(
                None, "Utwórz inną warstwę", "Warstwa o wybranej geometrii jest już w projekcie!")
            self.clear_createLayerBox()

    def get_layer_path(self):
        """Opens dialog box to selecte edited layer with monuments. In the event of a problem an message appears.
        """
        self.open_layer_path = QFileDialog.getOpenFileName(
            None, "Wybierz plik shapefile", "", "Shapefile (*.shp)")
        if len(self.open_layer_path[0]) == 0:
            msg = QMessageBox.critical(
                None, "Wybierz plik shapefile", "Nie wybrano pliku shapefile!")
        else:
            self.inputLE.setText(self.open_layer_path[0])
            if "zabytki_powierzchniowe" in self.inputLE.text() or "zabytki_punktowe" in self.inputLE.text() or "zabytki_liniowe" in self.inputLE.text():
                self.set_enabled_of_widget({self.openLayerBtn: True})
            else:
                msg = QMessageBox.critical(
                    None, "Wybierz prawidłowy plik shapefile", "Wybrano nieprawidłowy shapefile!")

    def open_layer(self):
        """Loads selected layer (to edition) to Qgis project. In the event of a problem an message appears.
        """
        layers_list = QgsProject.instance().mapLayersByName(
            self.create_layers_names()[0])
        if layers_list == []:
            opened_layer = QgsVectorLayer(
                self.open_layer_path[0], self.create_layers_names()[0], 'ogr')
            if opened_layer.isValid():
                crs = QgsCoordinateReferenceSystem('EPSG:2180')
                opened_layer.setCrs(crs)
                QgsProject.instance().addMapLayers([opened_layer])
                self.create_functions_layer()
                self.clear_editLayerBox()
            else:
                msg = QMessageBox.critical(
                    None, "Wybierz prawidłowy plik Shapefile", "Problem z ładowaniem pliku Shapefile do projektu!")
                self.clear_editLayerBox()
        else:
            msg = QMessageBox.critical(
                None, "Wybierz inny plik shapefile", "Wybrany plik jest już otwarty w projekcie!")
            self.clear_editLayerBox()

    def clear_form(self):
        """Clear plugin boxes.
        """
        self.save_layer_path = ""
        self.open_layer_path = ""
        self.set_exclusive_of_butons_group(
            {self.actionBtnGroup: False, self.geometryBtnGroup: False})
        self.set_checked_of_widget({self.polygonRBtn: False, self.pointRBtn: False,
                                   self.lineRBtn: False, self.createLayerRBtn: False, self.editLayerRBtn: False})
        self.set_enabled_of_widget(
            {self.selectActionBox: True, self.createLayerBox: False, self.editLayerBox: False})
        self.set_exclusive_of_butons_group({self.actionBtnGroup: True})
        self.clear_widget([self.outputLE, self.inputLE])

    def close_window_plugin(self):
        """Clear plugin boxes and closes window plugin.
        """
        self.clear_form()
        self.close()
